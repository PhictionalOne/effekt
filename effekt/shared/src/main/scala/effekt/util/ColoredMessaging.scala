package effekt
package util

import effekt.symbols.{ Capture, Captures, Effects, ErrorMessageInterpolator, LocalName, Name, NoName, QualifiedName, TypePrinter }
import effekt.util.messages.*
import kiama.util.{ Messaging, Position, Positions, Severities }
import kiama.util.Severities._

trait ColoredMessaging extends EffektMessaging {

  // Colors
  // ------

  def yellow(s: String): String
  def red(s: String): String
  def white(s: String): String
  def bold(s: String): String
  def bold_red(s: String): String
  def highlight(s: String): String
  def underlined(s: String): String

  def indent(s: String): String = s.linesIterator.map(l => "  " + l).mkString("\n")

  def severityToWord(severity: Severity): String =
    severity match {
      case Error       => red("error")
      case Warning     => yellow("warning")
      case Information => white("info")
      case Hint        => "hint"
    }

  override def formatMessage(message: EffektError): String = ""

  def formatMessage(message: EffektError, from: Position): String = ""

  def formatMessage(message: EffektError, from: Position, to: Position): String = ""

  /**
   * To allow uniform testing on all platforms, we homogenize the paths to Unix-style.
   *
   * This way the negative tests look the same on Windows and Linux
   */
  private def homogenizePath(label: String): String =
    label.replace('\\', '/')

  // Filter out duplicates
  // TODO this is a hack and should be solved in typer, where the messages are generated by unification
  override def formatMessages(messages: Messages): String =
    messages.sorted.map(formatMessage).distinct.mkString("")

  override def formatContent(err: EffektError): String = ""
  def fullname(n: Name): String = ""
}

class PlainMessaging extends ColoredMessaging {
  def yellow(s: String): String = s
  def red(s: String): String = s
  def white(s: String): String = s
  def bold(s: String): String = s
  def bold_red(s: String): String = s
  def highlight(s: String): String = s
  def underlined(s: String): String = s

  // Don't show context in plain messaging.
  override def formatMessage(message: EffektError, from: Position): String = {
    val severity = severityToWord(message.severity)
    s"[$severity] ${from.format} ${formatContent(message)}\n"
  }

  override def formatMessage(message: EffektError, from: Position, to: Position): String =
    formatMessage(message, from)
}

class AnsiColoredMessaging extends ColoredMessaging {
  def yellow(s: String): String = Console.YELLOW + s + Console.RESET
  def red(s: String): String = Console.RED + s + Console.RESET
  def white(s: String): String = Console.WHITE + s + Console.RESET
  def bold(s: String): String = Console.BOLD + s + Console.RESET
  def bold_red(s: String): String = Console.BLACK + Console.RED_B + s + Console.RESET
  def highlight(s: String): String = Console.BLACK + Console.WHITE_B + s + Console.RESET
  def underlined(s: String): String = Console.UNDERLINED + s + Console.RESET
}

