module stringbuffer

import bytearray

interface StringBuffer {
  def write(str: String): Unit
  def flush(): String
}

def StringBuffer(): StringBuffer at {global} = {
  val initialCapacity = 128
  var buffer in global = bytearray::allocate(initialCapacity)
  // next free index to write to
  var pos in global = 0

  def ensureCapacity(sizeToAdd: Int): Unit = {
    val cap = buffer.size - pos + 1
    if (sizeToAdd <= cap) ()
    else {
      // Double the capacity while ensuring the required capacity
      val newSize = max(buffer.size * 2, buffer.size + sizeToAdd)
      val newBuffer = bytearray::allocate(newSize)
      // copy content of old buffer into newly allocated buffer
      pos = 0
      buffer.foreach { b =>
        newBuffer.unsafeSet(pos, b)
        pos = pos + 1
      }
      buffer = newBuffer
    }
  }

  def stringBuffer = new StringBuffer {
    def write(str) = {
      val bytes = fromString(str)
      ensureCapacity(bytes.size)
      bytes.foreach { b =>
        buffer.unsafeSet(pos, b)
        pos = pos + 1
      }
    }

    def flush() = {
      val str = buffer.toString()
      buffer = bytearray::allocate(initialCapacity)
      str
    }
  }

  stringBuffer
}

namespace examples {
  def main() = {
    def buffer = StringBuffer()
    buffer.write("hello")
    buffer.write(", world")
    // prints `hello, world`
    println(buffer.flush())
    // prints the empty string
    println(buffer.flush())
  }
}
