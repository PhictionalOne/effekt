module io/async

import text/string

import mutable/ref
import immutable/dequeue
import immutable/result

extern """
const fs = require("fs")
"""



// Asynchronous I/O
// ----------------

interface IO {
  /**
   * Runs the provided computation and conceptually waits until it completes by
   * calling the writer-continuation.
   *
   * The provided writer-continuation should only ever be called ONCE.
   * The computation is passed as a thunk in order to prevent accidental usage of
   * other control effects that would violate the contract of calling the writer
   * once.
   */
  def performIO[T](computation: (T => Unit at {io,global}) => Unit at {io,global}): T
}

interface Process {
  def fork(p: Task[Unit]): Unit
  def yield(): Unit
  def exit(): Nothing
}

interface Promises {
  def async[T](p: Task[T]): Promise[T]
  def await[T](p: Promise[T]): T
}

type Task[T] = () => T / { IO, Process, Promises } at {io, global}

type PromiseState[T] {
  Unresolved()
  Resolved(value: T)
  Awaited(callbacks: List[T => Unit at {io, global}])
}

type Promise[T] = Ref[PromiseState[T]]

def fresh[T](): Promise[T] = fresh(Unresolved())

def eventloop(prog: Task[Unit]) = {

  // TODO we need to replace this by a mutable queue
  var queue: Dequeue[() => Unit at {global, io}] in global = emptyQueue();

  var iterations in global = 0;

  var openIOTasks in global = 0;

  def run(): Unit = {
    iterations = iterations + 1;
    queue.popBack match {
      case Some((k, q)) =>
        queue = q;
        setTimeout(0, box { k(); run() })
      case None() and openIOTasks > 0 =>
        // Busy waiting
        // Using openIOTasks and busy waiting is mostly for instructive purposes.
        // Instead, we could also make sure a call to `run()` is part of the captured continuation
        // of the IO task to "wake up" the scheduler.
        setTimeout(0, run)
      case _ =>
        println("leaving event loop after " ++ iterations.show ++ " iterations.")
    }
  }

  def handle(p: Task[Unit]): Unit =
    try { p() }
    with Process {
      def yield() = {
        queue = queue.pushFront(fun() { resume(()) })
      }

      def fork(task) = {
        queue = queue.pushFront(box { handle(task) })
        resume(())
      }

      def exit() = {
        ()
      }
    }
    with IO {
      def performIO[T](computation) = {
        openIOTasks = openIOTasks + 1
        computation(box { res => openIOTasks = openIOTasks - 1; resume(res) })
      }
    }
    with Promises {
      def async[T](task) = {

        def resolve[T](p: Promise[T], v: T): Unit = p.get match {
          case Unresolved() => p.set(Resolved(v))
          case Resolved(v) => panic("Promise already resolved")
          case Awaited(ks) =>
            p.set(Resolved(v))
            ks.foreach { k =>
              queue = queue.pushBack(box { k(v) })
            }
        }

        val promise: Promise[T] = fresh();
        queue = queue.pushFront(box { handle(box { resolve(promise, task()) }) })
        resume(promise)
      }
      def await[T](promise) = promise.get match {
        case Unresolved() => promise.set(Awaited(Cons(resume, Nil())))
        case Resolved(v) => resume(v)
        case Awaited(ks) => promise.set(Awaited(Cons(resume, ks)))
      }
    }

  // implement the concurrency / io actions (collecting tasks)
  handle(prog);

  // run the scheduler
  run()
}


namespace files {

  /**
   * Reads a file at given path in a utf8 encoded string.
   *
   * Also see: <https://github.com/nodejs/node/blob/main/src/node_file.cc#L2382>
   * Also see: <https://nodejs.org/api/fs.html#fsreadfilepath-options-callback>
   */
  extern io def readFileCallback(path: String, onSuccess: String => Unit at {io, global}): Unit =
    "fs.readFile(${path}, 'utf8', (err, res) => { if (!!err) { throw err } else { (${onSuccess})(res).run() } })"

  def readFile(path: String): String / IO =
    do performIO[String](box { write =>
      readFileCallback(path, write)
    })

  def readFilePromise(path: String): Promise[String] / Promises = do async(box { readFile(path) })
}

namespace console {
  extern """
    const readline = require('node:readline');
  """

  interface Console {
    def readline(): String / IO
  }

  namespace js {
    extern type JSConsole
    extern {io} def newConsole(): JSConsole =
      """readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        })"""
    extern {io} def close(console: JSConsole): Unit = "${console}.close()"
    extern {io} def readlineCallback(console: JSConsole, k: String => Unit at {io, global}): Unit =
      "${console}.question('', input => (${k})(input).run())"
  }

  def withConsole[R] { prog: => R / Console }: R = {
    val c = js::newConsole()
    try { val res = prog(); js::close(c); res } with Console {
      def readline() = resume {
        do performIO[String](box { write =>
          js::readlineCallback(c, write)
        })
      }
    }
  }
}

extern io def setTimeout(millis: Int, prog: () => Unit at {global, io}): Unit =
  "setTimeout(() => (${prog})().run(), ${millis})"

def countFile(): Int / IO = console::withConsole {
  println("Please enter filename:")
  val filename = do console::readline()
  println("Now reading: " ++ filename)
  files::readFile(filename).length
}

def main() = eventloop(box {

  val p1 = do async(box { countFile() })

  println("Trying to read package.json")
  val p2 = files::readFilePromise("package.json");

  println("result: " ++ do await(p1).show ++ " and " ++ do await(p2).length.show)
})
