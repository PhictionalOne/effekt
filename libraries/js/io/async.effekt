module io/async

import text/string

import mutable/ref
import mutable/buffer

import immutable/dequeue
import immutable/result


extern type Bytes
extern pure def size(b: Bytes): Int = "${b}.length"
extern pure def empty(): Bytes = "(new Uint8Array(0))"
extern pure def toBytes(s: String): Bytes = "(new TextEncoder().encode(${s}))"
extern pure def toString(b: Bytes): String = "(new TextDecoder('utf-8').decode(${b}))"


// Asynchronous I/O
// ----------------

interface IO {
  /**
   * Runs the provided computation and conceptually waits until it completes by
   * calling the writer-continuation.
   *
   * The provided writer-continuation should only ever be called ONCE.
   * The computation is passed as a thunk in order to prevent accidental usage of
   * other control effects that would violate the contract of calling the writer
   * once.
   */
  def performIO[T](computation: (T => Unit at {io,global}) => Unit at {io,global}): T
}

namespace IO {
  /**
   * Run an IO computation (that uses callbacks) here.
   */
  def run(program: () => Unit / IO at {io, global}): Unit =
    try { program() }
    with IO {
      def performIO[T](computation) = computation(resume)
    }
}


interface Process {
  def fork(p: Task[Unit]): Unit
  def yield(): Unit
  def exit(): Nothing
}


// Promises
// --------

interface Promises {
  def async[T](p: Task[T]): Promise[T]
  def await[T](p: Promise[T]): T
}

type Task[T] = () => T / { IO, Process, Promises } at {io, global}

type PromiseState[T] {
  Unresolved()
  Resolved(value: T)
  Awaited(callbacks: List[T => Unit at {io, global}])
}

type Promise[T] = Ref[PromiseState[T]]

def fresh[T](): Promise[T] = fresh(Unresolved())

// TODO only used right now, since there is a bug with global regions
extern pure def globalRegion(): Region at {global} = "$effekt.global"
def global = globalRegion()

def eventloop(prog: Task[Unit]) = {

  val queue: Buffer[() => Unit at {io, global}] at {io, global} = emptyBuffer(100) {global};

  // TODO implement resizing
  def enqueue(task: () => Unit at {io, global}): Unit =
    ignoring[BufferOverflow] { queue.write(task) }

  var iterations in global = 0;

  var openIOTasks in global = 0;

  def run(): Unit = {
    iterations = iterations + 1;
    queue.read() match {
      case Some(k) =>
        setTimeout(0, box { k(); run() })
      case None() and openIOTasks > 0 =>
        // Busy waiting
        // Using openIOTasks and busy waiting is mostly for instructive purposes.
        // Instead, we could also make sure a call to `run()` is part of the captured continuation
        // of the IO task to "wake up" the scheduler.
        setTimeout(0, run)
      case _ =>
        println("leaving event loop after " ++ iterations.show ++ " iterations.")
    }
  }

  def handle(p: Task[Unit]): Unit =
    try { p() }
    with Process {
      def yield() = {
        enqueue(box { resume(()) })
      }

      def fork(task) = {
        enqueue(box { println("Back in server loop"); resume(()) })
        enqueue(box { println("In handling thread"); handle(task) })
      }

      def exit() = {
        ()
      }
    }
    with IO {
      def performIO[T](computation) = {
        openIOTasks = openIOTasks + 1
        computation(box { res =>
          openIOTasks = openIOTasks - 1;
          // Move task to the ready-queue
          enqueue(box { resume(res) })
        })
      }
    }
    with Promises {
      def async[T](task) = {

        def resolve[T](p: Promise[T], v: T): Unit = p.get match {
          case Unresolved() => p.set(Resolved(v))
          case Resolved(v) => panic("Promise already resolved")
          case Awaited(ks) =>
            p.set(Resolved(v))
            ks.foreach { k =>
              // was pushBack
              enqueue(box { k(v) })
            }
        }

        val promise: Promise[T] = fresh();
        enqueue(box { handle(box { resolve(promise, task()) }) })
        resume(promise)
      }
      def await[T](promise) = promise.get match {
        case Unresolved() => promise.set(Awaited(Cons(resume, Nil())))
        case Resolved(v) => resume(v)
        case Awaited(ks) => promise.set(Awaited(Cons(resume, ks)))
      }
    }


  // implement the concurrency / io actions (collecting tasks)
  handle(prog);

  // run the scheduler
  run()
}


namespace files {

  extern """
    const fs = require("fs");
  """

  /**
   * Reads a file at given path in a utf8 encoded string.
   *
   * Also see: <https://github.com/nodejs/node/blob/main/src/node_file.cc#L2382>
   * Also see: <https://nodejs.org/api/fs.html#fsreadfilepath-options-callback>
   */
  extern io def readFileCallback(path: String, onSuccess: String => Unit at {io, global}): Unit =
    "fs.readFile(${path}, 'utf8', (err, res) => { if (!!err) { throw err } else { (${onSuccess})(res).run() } })"

  def readFile(path: String): String / IO =
    do performIO[String](box { write =>
      readFileCallback(path, write)
    })

  def readFilePromise(path: String): Promise[String] / Promises = do async(box { readFile(path) })
}

namespace network {

  extern """
    const net = require('node:net');

    function withServer(port, handler) {
      const server = net.createServer((socket) => {
        handler(socket)
      })
      server.listen(port)
    }
    function listen(server, port, host, listener) {
      server.listen(port, host);
      server.on('connection', listener);
    }
  """

  extern type JSServer // = net.Server
  extern type JSSocket // = net.Socket
  extern io def jsServer(): JSServer = "net.createServer()"
  extern io def jsListen(server: JSServer, port: Int, host: String, listener: JSSocket => Unit at {io, global}): Unit = "listen(${server}, ${port}, ${host}, (socket) => (${listener})(socket).run())"

  extern io def jsSend(socket: JSSocket, data: Bytes, callback: () => Unit at {io, global}): Unit =
    "${socket}.write(${data}, () => (${callback})().run())"

  extern io def jsReceive(socket: JSSocket, callback: Bytes => Unit at {io, global}): Unit =
    "${socket}.once('data', (data) => (${callback})(data).run())"

  extern io def jsEnd(socket: JSSocket, callback: () => Unit at {io, global}): Unit =
    "${socket}.end(() => (${callback})().run())"

  interface Socket {
    def send(message: Bytes): Unit
    def receive(): Bytes
    def end(): Unit
  }

  def server(host: String, port: Int, handler: () => Unit / { Socket, IO, Process, Promises } at {io, global}): Unit / { Process, IO } = {
    val server = jsServer();
    var connections: Dequeue[JSSocket] in global = emptyQueue()
    server.jsListen(port, host, box { socket =>
      println("new connection")
      connections = connections.pushFront(socket)
    })

    // TODO Instead of polling, we should use Channels
    loop {
      connections.popBack match {
        case Some((socket, cs)) =>
          connections = cs;
          do fork(box {
            try { handler() } with Socket {
              def send(message) = {
                do performIO[Unit](box { k =>
                  socket.jsSend(message, box { k(()) })
                });
                resume(())
              }
              def receive() = {
                resume(do performIO[Bytes](box { k =>
                  socket.jsReceive(k)
                }))
              }
              def end() = {
                do performIO[Unit](box { k =>
                  socket.jsEnd(box { k(()) })
                });
                resume(())
              }
            }
          })
        case None() =>
          do yield()
      }
    }
  }
  // creates a simple echo server.
  def example() = eventloop(box {
    var x in global = 0;
    server("localhost", 8080, box {
      loop {
        val msg = do receive();
        x = x + 1
        //println("Received a request: " ++ msg.toString)
        if (msg.toString.startsWith("GET /")) {
          if (x <= 1) {
            wait(10000)
          }
          do send(toBytes("HTTP/1.1 200 OK\r\n\r\nHello from Effekt!"))
        } else {
          do send("HTTP/1.1 400 Bad Request\r\n\r\n".toBytes)
        }
        do end()
      }
    })
  })
}

namespace console {
  extern """
    const readline = require('node:readline');
  """

  interface Console {
    def readline(): String / IO
  }

  namespace js {
    extern type JSConsole
    extern {io} def newConsole(): JSConsole =
      """readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        })"""
    extern {io} def close(console: JSConsole): Unit = "${console}.close()"
    extern {io} def readlineCallback(console: JSConsole, k: String => Unit at {io, global}): Unit =
      "${console}.question('', input => (${k})(input).run())"
  }

  def withConsole[R] { prog: => R / Console }: R = {
    val c = js::newConsole()
    try { val res = prog(); js::close(c); res } with Console {
      def readline() = resume {
        do performIO[String](box { write =>
          js::readlineCallback(c, write)
        })
      }
    }
  }
}

extern io def setTimeout(millis: Int, prog: () => Unit at {io, global}): Unit =
  "setTimeout(() => (${prog})().run(), ${millis})"

def wait(millis: Int): Unit / IO =
  do performIO(box { k => setTimeout(millis, box { () => k(()) }) })

def countFile(): Int / IO = console::withConsole {
  println("Please enter filename:")
  //val filename = do console::readline()
  val filename = "README.md"
  wait(10000)
  println("Now reading: " ++ filename)
  files::readFile(filename).length
}


def main() = network::example()

def main2() = eventloop(box {

  val p1 = do async(box { countFile() })

  println("Trying to read package.json")
  val p2 = files::readFilePromise("package.json");

  println("result: " ++ do await(p1).show ++ " and " ++ do await(p2).length.show)
})
