module io/async

import text/string

import mutable/ref
import immutable/dequeue
import immutable/result

extern """
const fs = require("fs")
"""



// Asynchronous I/O
// ----------------

interface IO {
  /**
   * Runs the provided computation and conceptually waits until it completes by
   * calling the writer-continuation.
   *
   * The provided writer-continuation should only ever be called ONCE.
   * The computation is passed as a thunk in order to prevent accidental usage of
   * other control effects that would violate the contract of calling the writer
   * once.
   *
   * TODO better names!
   */
  def performIO[T](computation: (T => Unit at {io,global}) => Unit at {io,global}): T
}

interface Process {
  def fork(p: Task[Unit]): Unit
  def yield(): Unit
  def exit(): Nothing
}

interface Promises {
  def async[T](p: Task[T]): Promise[T]
  def await[T](p: Promise[T]): T
}

type Task[T] = () => T / { Process, IO, Promises } at {io, global}

type PromiseState[T] {
  Unresolved()
  Resolved(value: T)
  Awaited(callbacks: List[T => Unit at {io, global}])
}

type Promise[T] = Ref[PromiseState[T]]

def fresh[T](): Promise[T] = fresh(Unresolved())

def eventloop(prog: Task[Unit]) = {

  // TODO we need to replace this by a mutable queue
  var queue: Dequeue[() => Unit at {global, io}] in global = emptyQueue();

  var iterations in global = 0;

  var openIOTasks in global = 0;

  def run(): Unit = {
    iterations = iterations + 1;
    queue.popBack match {
      case Some((k, q)) =>
        queue = q;
        setTimeout(0, box { k(); run() })
      case None() and openIOTasks > 0 =>
        // Busy waiting
        // Using openIOTasks and busy waiting is mostly for instructive purposes.
        // Instead, we could also make sure a call to `run()` is part of the captured continuation
        // of the IO task to "wake up" the scheduler.
        setTimeout(0, run)
      case _ =>
        println("leaving event loop after " ++ iterations.show ++ " iterations.")
    }
  }

  def handle(p: Task[Unit]): Unit =
    try { p() }
    with Process {
      def yield() = {
        queue = queue.pushFront(fun() { resume(()) })
      }

      def fork(task) = {
        queue = queue.pushFront(box { handle(task) })
        resume(())
      }

      def exit() = {
        ()
      }
    }
    with IO {
      def performIO[T](computation) = {
        openIOTasks = openIOTasks + 1
        computation(box { res => openIOTasks = openIOTasks - 1; resume(res) })
      }
    }
    with Promises {
      def async[T](task) = {

        def resolve[T](p: Promise[T], v: T): Unit = p.get match {
          case Unresolved() => p.set(Resolved(v))
          case Resolved(v) => panic("Promise already resolved")
          case Awaited(ks) =>
            p.set(Resolved(v))
            ks.foreach { k =>
              queue = queue.pushBack(box { k(v) })
            }
        }

        val promise: Promise[T] = fresh();
        queue = queue.pushFront(box { handle(box { resolve(promise, task()) }) })
        resume(promise)
      }
      def await[T](promise) = promise.get match {
        case Unresolved() => promise.set(Awaited(Cons(resume, Nil())))
        case Resolved(v) => resume(v)
        case Awaited(ks) => promise.set(Awaited(Cons(resume, ks)))
      }
    }

  // implement the concurrency / io actions (collecting tasks)
  handle(prog);

  // run the scheduler
  run()
}


namespace files {

  /**
   * Reads a file at given path in a utf8 encoded string.
   *
   * Also see: <https://github.com/nodejs/node/blob/main/src/node_file.cc#L2382>
   * Also see: <https://nodejs.org/api/fs.html#fsreadfilepath-options-callback>
   */
  extern io def readFileCallbacks(path: String, onSuccess: String => Unit at {io, global}): Unit =
    "fs.readFile(${path}, 'utf8', (err, res) => { if (!!err) { throw err } else { (${onSuccess})(res).run() } })"

  def readFile(path: String): String / IO =
    do performIO[String](box { write =>
      readFileCallbacks(path, write)
    })

  def readFilePromise(path: String): Promise[String] / Promises = do async(box { readFile(path) })
}

extern io def setTimeout(millis: Int, prog: () => Unit at {global, io}): Unit =
  "setTimeout(() => (${prog})().run(), ${millis})"


def main() = eventloop(box {
  val p1 = files::readFilePromise("README.md")
  val p2 = files::readFilePromise("package.json")

  println("result: " ++ do await(p1).length.show ++ " and " ++ do await(p2).length.show)
})
