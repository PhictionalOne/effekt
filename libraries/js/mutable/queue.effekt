module mutable/queue

import mutable/array

/**
 * Mutable, automatically resizing queue.
 */
interface Queue[T] {
  def empty?(): Bool

  def popFront(): Option[T]

  def popBack(): Option[T]

  def peekFront(): Option[T]

  def peekBack(): Option[T]

  def pushFront(el: T): Unit

  def pushBack(el: T): Unit
}


def emptyQueue[T](): Queue[T] at {global} =
  emptyQueue[T](64)

def emptyQueue[T](initialCapacity: Int): Queue[T] at {global} = {
  var contents in global = emptyArray[T](initialCapacity)
  var head in global = 0
  var tail in global = 0
  var size in global = 0
  var capacity in global = initialCapacity

  def nonEmpty[T] { p: => Option[T] }: Option[T] =
    if (size <= 0) None() else p()

  // Exponential back-off
  def resizeTo(requiredSize: Int): Unit =
    if (requiredSize <= capacity) () else {
      val oldSize = capacity
      val newSize = capacity * 2
      val oldContents = contents
      val newContents = emptyArray[T](newSize)

      if (head < tail) {
        // The queue does not wrap around; direct copy is possible.
        copy(oldContents, head, tail, newContents, 0)
      } else if (size > 0) {
        // The queue wraps around; copy in two segments.
        copy(oldContents, head, oldSize, newContents, 0)
        copy(oldContents, 0, tail, newContents, oldSize - head)
      }

      contents = newContents
      capacity = newSize
      head = 0
      tail = oldSize
    }

  def queue = new Queue[T] {
    def empty?() = size <= 0

    def popFront() =
      nonEmpty {
        val result = contents.get(head)
        // contents(head) = null // Clear the reference.
        head = mod(head + 1, capacity)
        size = size - 1
        result
      }

    def popBack() =
      nonEmpty {
        tail = mod(tail - 1 + capacity, capacity)
        val result = contents.get(tail)
        size = size - 1
        // contents(tail) = null // Clear the reference.
        result
      }

    def peekFront() = nonEmpty { contents.get(head) }

    def peekBack() = nonEmpty { contents.get(tail) }

    def pushFront(el: T) = {
      resizeTo(size + 1);
      head = mod(head - 1 + capacity, capacity);
      size = size + 1;
      contents.put(head, el)
    }

    def pushBack(el: T) = {
      resizeTo(size + 1);
      contents.put(tail, el);
      size = size + 1;
      tail = mod(tail + 1, capacity)
    }
  }
  queue
}
