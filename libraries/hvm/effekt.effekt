module effekt

extern include hvm "effekt.hvm"

//String ops
/*
extern io def println[R](r: R): Unit =
  hvm "(HVM.print ${r} ${r})"



extern pure def show[R](value: R): String =
  hvm "(HVM.log ${value} ${value})"

*/
//extern pure def infixConcat(s1: String, s2: String): String =
//  "${s1} + ${s2}"

extern io def println(r: String): Unit =
  hvm "(IO/bind (IO/print r) *)"

//Math ops

extern def infixAdd(x: Int, y: Int): Int =
  hvm "(+ ${x} ${y})"

extern def infixMul(x: Int, y: Int): Int =
  hvm "(* ${x} ${y})"

extern def infixDiv(x: Int, y: Int): Int =
  hvm "(/ ${x} ${y})"


extern def infixSub(x: Int, y: Int): Int =
  hvm "(- ${x} ${y})"

extern def mod(x: Int, y: Int): Int =
  hvm "(% ${x} ${y})"

/*
extern def infixAdd(x: Double, y: Double): Double =
  hvm "(+ ${x} ${y})"

extern def infixMul(x: Double, y: Double): Double =
  hvm "(* ${x} ${y})"

extern def infixDiv(x: Double, y: Double): Double =
  hvm "(/ ${x} ${y})"

extern def infixSub(x: Double, y: Double): Double =
  hvm "(- ${x} ${y})"
*/

def min(n: Int, m: Int): Int =
  if (n < m) n else m

def max(n: Int, m: Int): Int =
  if (n > m) n else m

//Comparison ops

extern def infixEq[R](x: R, y: R): Bool =
  hvm "(== ${x} ${y})"

extern def infixNeq[R](x: R, y: R): Bool =
  hvm "(!= ${x} ${y})"

extern def infixLt(x: Int, y: Int): Bool =
  hvm "(< ${x} ${y})"

extern def infixLte(x: Int, y: Int): Bool =
  hvm "(| (< ${x} ${y}) (== ${x} ${y}))"

extern def infixGt(x: Int, y: Int): Bool =
  hvm "(> ${x} ${y})"

extern def infixGte(x: Int, y: Int): Bool =
  hvm "(| (> ${x} ${y}) (== ${x} ${y}))"

/*
extern def infixLt(x: Double, y: Double): Bool =
  hvm "(< ${x} ${y})"

extern def infixLte(x: Double, y: Double): Bool =
  hvm "(<= ${x} ${y})"

extern def infixGt(x: Double, y: Double): Bool =
  hvm "(> ${x} ${y})"

extern def infixGte(x: Double, y: Double): Bool =
  hvm "(>= ${x} ${y})"
*/
//Bool ops

def not(b: Bool): Bool =
  if (b) false else true

/*extern def infixOr{ x: => Bool } { y: => Bool }: Bool =
  "(| ${x} ${y})"

extern def infixAnd{ x: => Bool } { y: => Bool }: Bool =
  "(& ${x} ${y})"
  */


def infixOr { first: => Bool } { second: => Bool }: Bool = 
  if (first()) true else second()

def infixAnd { first: => Bool } { second: => Bool }: Bool = 
  if (first()) second() else false
